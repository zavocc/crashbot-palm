import discord
from dotenv import load_dotenv
from os import getenv
from discord.ext import bridge, tasks
from itertools import cycle
import google.generativeai as palm
from pathlib import Path

#######################################################
# Pre-startup checks and initializations
#######################################################

if not Path("dev.env").is_file():
    raise Exception("dev.env file is missing. Please create one and try again.")

load_dotenv("dev.env")

if getenv("PALM_API_TOKEN") is None or getenv("PALM_API_TOKEN") == "INSERT_API_KEY":
    raise Exception("PALM_API_TOKEN is not configured in the dev.env file. Please configure it and try again.")

palm.configure(api_key=getenv("PALM_API_TOKEN"))

if getenv('TOKEN') is None:
    raise Exception("TOKEN is not configured in the dev.env file. Please configure it and try again.")

#######################################################
# Runtime variables
#######################################################
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
bot = bridge.Bot(command_prefix="cb!", intents = intents)

#######################################################
# Events and tasks
#######################################################

statuses = cycle([
    "Crash Bandicoot",
    "Crash Bandicoot 2: Cortex Strikes Back",
    "Crash Bandicoot 3: Warped",
    "Crash Team Racing",
    "Crash Bandicoot N. Sane Trilogy",
    "Crash Team Racing Nitro-Fueled",
    "Crash Bandicoot 4: It's About Time"
])

#https://stackoverflow.com/a/65780398
@tasks.loop(seconds=180)
async def change_status():
    await bot.change_presence(activity=discord.Game(next(statuses)))

#######################################################
# CONTEXTUAL MEMORY
#######################################################
context_history = {}

@bot.event
async def on_ready():
    print(f"{bot.user} is ready and online!")
    change_status.start()

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    # Debug
    #print(type(message.content))
    #print(message.content)

    # Check if message starts with "Hey Crash"
    if str(message.content).upper().startswith("HEY CRASH"):
        if len(message.content.split(" ")) < 3:
            await message.channel.send(f"Hey {message.author.mention}, I'm Crash Bandicoot!")
            return

        if message.guild:
            guild_id = message.guild.id
        else:
            guild_id = message.author.id
        
        if guild_id not in context_history:
            context_history[guild_id] = []

        # Check if context history contains 20 inputs which we will purge the conversation history and start a new one
        # 20 is the overall maximum context history for server resource use, however the user can only respond to the last 10 messages with context
        if len(context_history[guild_id]) >= 10:
            await message.channel.send("⚠️ You have reached the maximum context history. Please start a new conversation using `cb!clearmemory`")
            return

        # Add prompt to context history and remove "Hey Crash" prefix
        prompt = message.content.split(" ", 2)[2]
        context_history[guild_id].append(prompt)

        # Generate response
        response = palm.chat(
            model="models/chat-bison-001",
            temperature=0.25,
            candidate_count=1,
            top_k=40,
            top_p=0.95,
            context="Be and act as Crash Bandicoot",
            messages=context_history[guild_id]
        )

        # Check to see if this message is more than 2000 characters which embeds will be used for
        embedmsg = False
        answer = None

        if len(response.last) > 2000:
            embedmsg=True
            answer = discord.Embed(
                title="Crash Bandicoot",
                description=response.last,
                color=discord.Color.orange()
            )
            answer.set_footer(text="Responses generated by AI may not be accurate")

        if embedmsg:
            await message.channel.send(embed=answer)
        else:
            await message.channel.send(response.last)

        # Add response to context history
        context_history[guild_id].append(response.last)

        # The number of inputs the user can respond to is 10 but 20 since it also includes the answer
        await message.channel.send(f"Context size: **{len(context_history[guild_id])}** of 10")

#######################################################
# FUNCTIONS
#######################################################
@bot.slash_command()
async def clearmemory(ctx):
    """Clear Crash's memory"""
    if ctx.guild:
        guild_id = ctx.guild.id
    else:
        guild_id = ctx.author.id

    if len(context_history[guild_id]) == 0:
        await ctx.respond("Memory is already clear!")
        return

    context_history[guild_id].clear()
    await ctx.respond("Memory cleared!")

# Universal clear memory command
@bot.slash_command()
async def clearmemoryu(ctx):
    """Clear Crash's memory in all guild instances (Requires owner)"""
    if ctx.author.id != 1039885147761283113:
        await ctx.respond("Only bot owner can use this command!")
        return
    
    if context_history is None or len(context_history) == 0:
        await ctx.respond("Memory is already clear!")
        return
    
    context_history.clear()
    await ctx.respond("Memory cleared across guild instances!")

@bot.slash_command()
async def listconvos(ctx):
    """List all conversations in Crash's memory"""
    if ctx.guild:
        guild_id = ctx.guild.id
    else:
        guild_id = ctx.author.id

    if guild_id not in context_history:
        context_history[guild_id] = []

    memory = ". ".join(context_history[guild_id])

    if len(context_history[guild_id]) == 0:
        await ctx.respond("Memory is empty!")
        return
    
    if len(memory) > 2000:
        await ctx.respond("Memory is too large to display!")
        return

    await ctx.respond(memory)

bot.run(getenv('TOKEN')) 
